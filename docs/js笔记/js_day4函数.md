# 函数

## 1.介绍

* 函数: 我们吧一段相对独立具有特定功能的代码封装起来,形成一个独立试题,七个名字(函数名), 以后的后续开发可以随时反复调用.
* 作用:封装(包起来),一段代码,将来可以随时拿来使用.

## 2.语法

```JS
//function 声明函数 ___ fun 函数的名字(方便调用)
  function fun() {
 //行数提,我们封装,准备随时调用的一段函数.
       console.log("你好");
  }
```

* 调用: 声明的函数 ,一段代码呗包起来; 需要贝蒂阿勇的时候会执行当前函数;

```js
fun();

//调用需要函数名加上();就可以调用,如果需要使用多次,就复制多次
fun();
fun();
fun();
```

* 起名字重复会覆盖,跟变量一样.



## 3.参数

### 1.配置参数

* 对于函数来说,**函数内部的变量**
* 一段代码执行,需要有变化量,不然复用率不好,不灵活
* 语法

```js
//在小括号内的变量,对于函数来说,就是参数
//参数就是函数内部的变量
//名后面小括号内的值(name)变量名
  function fun(name){
      //函数内部的变量跟外面的变量使用方法相同
       console.log("你好" + name);
  }
```

### 2.形参~实参

* **形参**
  * 对于函数,这些在内部使用的参数都是形参,代替位置,站住这个坑;
  * **形参**没有实际的值参加计算
* **实参**
  * 相对于形参来讲,有实际的数值,
  * **实参**需要把其内部的值传入**形参**以参与计算,
  * **形参**与**实参**的关系仅仅是函数声明时的位置顺序关系,
  * **形参**的名字与**实参**的名字无强行规定,一定相同
  * **仅仅是实参的值需要传入函数内部,形参只是一个标识**;

* **相互不影响**
  * 只能传入简单值类型,互不影响

```js
var a = 10;
var b = 20;

function fn(x,y){
  x = x + y;
  console.log(x,y);
}

// 传入实参a b，相当于是变量a的值，赋值给了函数内部变量x，
// x再以后的运算和a没有任何关系；
// 输出 30，20
fnm(a,b); 

// 输出 10,20 a的值并没有受到x的变化影响
console.log(a,b);
```

### 3.参数未赋值

* 变量;

  如果函数内部的变量未赋值, 默认为undefined,和我们的变量一模一样

```js
function tellStroy(name){
  console.log("从前有座山，山里有座庙");
  console.log("庙里有个老和尚在给小和尚讲故事");
  console.log("讲的是什么呢？");
  console.log("老和尚对"+ name +"说：");   // 老和尚对undefined说；
}
```

* 解决

```js
function tellStroy(name){
    
  // if 条件语句
  if(name==undefined) {
      name = '小和尚'
  }
  else {
      name = name;
  }
  
  // 三元表达式；
  name = name?name:"小和尚"；
  console.log("从前有座山，山里有座庙");
  console.log("庙里有个老和尚在给小和尚讲故事");
  console.log("讲的是什么呢？");
  console.log("老和尚对"+ name +"说：");
}
```

### 4.返回值

* 需求:使用函数的方式求  两个数字的和
* 提炼函数,这个过程中,a和b是两个随时变化的数据,所以我们吧它们两个作为位参数

```js
var a = 10;
var b = 20;
var sum = a + b;

function getSum(a,b){
  var sum = a + b;
  // 只是打印；
  console.log(sum);
}
// 如果不想打印的话怎么获取到sum(和)呢,想在外面使用这个值,要在bady显示就需要吧函数内部的值输出出去.
```

#### (1)修改返回值
* **函数的返回值** : 函数执行完毕,会得到一个结果,这个结果就是这个函的返回值.

```js
//默认情况下,函数会返回,undefined,如果想改变这个值,使用"return" 关键字.
//在函数体内部
return  返回值;
//在函数体内部
当函数结束之后会返回一个值,就是return 后面跟的值;
```

#### (2)终止函数执行

* **return作用2**,终止函数的执行

```js
function fn(){
  console.log(1);
  console.log(2);
  return;
  console.log(3);
  console.log(4);
}
fn(); // 只输出了1和2，3和4没有执行，return 终止了函数的执行，即： return 后面的代码不会执行
```





## 实例

### 1.arguments 

* 说明:

  如果可以获取不确定数目的实参;

* 属性:

  隐藏变量,对于函数内部来说__外部不能获取

  * 有下标,可循环,可遍历;

  * 伪变量

* 使用:

```js
function fn(){
  console.log(arguments);
}
fn(1); // 输出 [1]
fn(1,2) // 输出 [1,2]
fn(1,2,3,4,5) // 输出 [1,2,3,4,5]

```

* arguments  他有数组的长度和顺序的特征有点像数组,称为伪数组
* 本质为**对象**
* arguments  伪数组可以**循环遍历**

```js
function getSum(){
  var sum = 0;
  for(var i = 0; i < arguments.length ; i++){
    sum += arguments[i];
  }
  return sum;
}

getSum(1,2,3);// 输出 6
getSum(1,2,3,4,5); // 输出15

```

* 应用场景: 当我们不知道我们参数的个数的时候



### 2.函数表达式

* js 声明函数的方式不止一种,还有一种方式是函数表达式
* 声明变量,赋值为函数

```js
var 函数名 = function (参数){
   //函数体
}

var getSum = function(a,b){
  return a + b;
}
getSum(10,20);
```



### 3.匿名函数

* 匿名函数：没有名字的函数，但是在js的语法中，是不允许匿名函数单独存在的，要配合其它语法使用：

如：

```js
function (参数){
  //函数体
}

var fn = function(a,b){
  return a + b;
}
//在使用函数表达式的方式创建的时候使用的就是匿名函数
// 匿名::在这称之为是没有写名字,但会赋值到var 后面创建的名字上面,
//不是真正的没有名字;
```



### 4.函数类型

```js
function fn(){}
console.log(typeof fn); // 输出 字符串的  function
```

* typeof 查询数据类型;
* **在js中，只要是一种数据类型的，都可以作为函数的参数**，

```js
function f1(a,b){
  return a + b;
}
f1(10,20); // 数字作为参数
f1('abc','def') // 字符串作为参数
```



### 5.回调函数

* **函数也有数据类型**,也可以作为别的函数的参数

```js
// fn 只不过在函数内部是一个形参，内部变量；
function f1(a,fn){
  console.log(a);
  // 函数的调用，在函数名的后面加括号；
  // 内部的函数对外面的函数叫回调函数；
  fn(); 
}

function f2(){
  console.log('f2函数执行了');
}
f1(10,f2);// 输出 10 和 'f2函数执行了'
```



## 作用域

* 为什么要学作用域？**目前，我们要分清楚自己的声明的变量在哪个作用域下，也就是生效的范围是多大；配合下面预解析的知识，经常是面试比较常问的基础题**；

* **全局作用域**
  * 全局作用域：作用范围，能生效的范围；
  * 全局变量: 在全局声明下的变量.(**在全局范围内全部都能访问生效**)
* **局部作用域**
  * 局部作用域:只在局部的作用域范围内进行**访问**.
  * 局部变量:在局部范围内声明的变量.

* 区别,
  * 局部在全局的内部,全局包含局部;
  * 如果是在全局和局部都声明的变量,
  * 在全局内引用是全局的效果,在局部引用是局部的效果.

```js
var a = 10;
function f1(){
  console.log(a);
}
f1();// 变量a在函数外定义，可以在函数内使用




function f2(){
  var b = 20;
}
// 变量b在函数内定义，在函数外无法访问，报错： b is not defined
console.log(b); 
```



​	

## 解析域

* 在生命的作用域范围内,声明的变量可以在**任何地方** 都可以访问,是**任何地方**
* 预解析:提前/解析(分析) 会把**初始化声明的变量,函数**,全部提升到**当前作用域**的最顶端;
* 也叫**变量提升**:从字面上理解,"变量提升"意味着变量和函数的声明会在物理层面移动到代码的最前面,但是这么说并不准确.实际上变量和函数耳朵声明位置是不会变动的,二是在编译阶段被放入到内存当中.
  * 变量:已经声明 函数: 已经声明.
  * 而变量的赋值和函数的调用还是在原来的位置.
* **找到当前作用域的最顶端,提升上去**

```js
fn();// 正常执行
function f1(){
  console.log(1);
}
fn(); // 正常执行


f2();// 报错 ： f2 is not a function
var f2 = function(){
  console.log(2);
}
// function 关键字定义的函数，可以在定义之前使用，函数表达式的不行
```

* 上面的代码解析后:

```js
function f1(){
  console.log(1);
}
var f2;
fn();
fn();

f2();
f2 = function(){
  console.log(2);
}
```

* 所以在调用f1的时候,其实函数已经声明好了,但是在调用f2的时候,f2 还是undefined,就会报错.

  

