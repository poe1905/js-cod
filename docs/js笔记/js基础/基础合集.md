# JavaScript 基础学习笔记

## 字符串



## 数组

### 数组

#### 介绍

* 数组是一个有序的列表,有长度的数据集合;
* 类型:Object;
* 特点
  * 把数据有序放在一块
  * 有长度;

声明

* 使用字面式 创建数组

```js
// [] 方括号里面可以添加数据方式,期间用逗号隔开可以作为声明数组的方式
var 数组名 = [];

```

* 使用构造函数创建

  数组在js中还可以使用另一种方式去创建,这个方式我们称之为**构造函数**

  构造函数:能构造一个你需要的东西(对象);

```js
// 使用 构造函数 创建数组
var arr = new Array();
//Array[əˈreɪ] 大量/大群的/大堆
// 存储数
arr[0] = 10;
arr[1] = 20;
console.log(arr);
//如果使用构造函创建 不要使用单个值赋值
var arr = new Array(10,20);
console.log(arr);
```



#### 存值

* 数组中有一个属性就是    **索引**     下标
* 下标可以说是一个图书馆的索引
* **下标从0开始**

```js
//数组名[下标] = 需要存的值;
a [0] =1 ;
a [2] =2 ;
a [3] =4 ;
a [4] =5 ;
a [5] =6 ;

console.log (a);
//会输出
//(6) [1, empty, 2, 4, 5, 6]
// 小括号 内的数字是说明这个数组的长度为6
//empty[ˈempti]空的; 
//因为我没给里面赋值所以会输出empty ;
```

* 数组的使用方式跟变量一样

```js
arr [2] = 100 ;
// 是吧100赋值给了arr这个数组的第二个位置
```

* 如果从一开始就知道数组内有限的数据就可以直接赋值

```js
var  arr= [ 1,2,3,4,5] ;
//下标分别是  0,1,2,3,4 
//因为下标是从0开始的所以一个4位数长度的数组内部存了5个数据
```
#### 使用构造函数存值
* 注意: 使用这种方式进行初始赋值的话不能单独服一个值;
  **单独赋值**//是给数组一个空间

```js
var arr = new Array(10);
console.log(arr); // 输出 [empty × 10]
```



* 数组的内部的数据类型可以为其他类型

  布尔值,文本型,数字型,浮点型.

#### 取值

* 把数据取出来 , 需要知道你需要取出数据的位置.
* 取值需要使用**索引** 也就是**下标**.

```js
//
var  arr= [ 1,2,3,4,5] ;
console.log (arr[0]);
//会输出1
console.log (arr[3]);
//会输出4

//把数组内的数据进行求和
var sun = arr[0]+arr[1]+arr[2]+arr[3]+arr[4];
console.log (sun);
  //会输出15

```

#### 遍历

* 如果数组的长度不确定就需要一个一个输入求和的公式
* 既然求和从0到最后,一个一个加起来的过程
* 发现了重复的思想,**有重复做一件事情,就可以使用循环**

```js
//循环,从零到最后一共是4个位数
var  arr= [ 1,2,3,4,5] ;
var sun = 0 ;
for (var i = 0 ; i <=4 ; i++ ){
	sun += arr [i];
    //sun =sun +arr[i];
    //这两行代码是相同的效果,第一个稍微方便一些
}
//在for 外面进行输出
console.log (sun);
//输出15
```

* 使用**循环**来遍历,当数组中的数据比较多的时候,会比较方便,一般使用的都是**for循环**;

#### 数组长度

* 语法
  * 存取数据: 设计到数组的**顺序**问题,通过索引去存取;
  * 数组的长度: 就是数组中一共存放了多少数据;

```js
  console.log(arr.length);
//length[leŋθ] 长度,度量,大小
//数组名.length 就可以返回数组长度
```

* 数组最多可以包含4294967295个项，基本上可以满足任何编程要求

#### 数组长度可以增减

* 数组长度增加的

```js
var arr = [1,2,3]
arr.length 5;
console.log (arr)
//输出 :1,2,3,undefined,undefined
```

* 输出的长度可以减少

```js
//多余删除
var arr = [1,2,3];
arr.length 2;
console.log (arr);
//输出 1,2
//数据的减少会造成数据的丢失,谨慎使用
```

* 删除数组元素

```js
var arr = [1,2,3,4,5];
delete arr [2] 
delete arr [3] 
console.log (arr); //1,2, undefined, undefined,5
//数组成员被删除,数组的长度不会改变,值是产出对应值删除为undefined
```

#### 数组的对话框输入

有某种情况需要使用

### 数组的方法

> 数组的操作方法

#### slice(start ,end)

* **不操作原数组** 截取数组中的某一部分到新的数组
* 参数
  * start --> 必填项 , 规定了slice方法从何处开始截取数组   如果是负数则从数组位开始计算开始项
  * end  --> 可选项  规定方法截取到那一位停止
* 返回     一个新的数组,数组中包括这截取出来新的数组
  * 可以通过arr.slice(0)的方式去复制一个新的数组,深拷贝出来的,(完整的截取整个数组)赋值给新的数组

#### sort(sortby)

* 排序一个数组, 操作原有数组对象

* 参数  `sortby`可选参数为一个==比较函数==
* 返回值为操作排序好的数组

```js
var  arr= [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
methods: {
        shuiji: function() {
          function sortby(a, b) {
              //随机整个数组的排列顺序
            return Math.random() > 0.5 ? -1 : 1
          }
          this.arr.sort(sortby)
        },
        paixu: function() {
          function sortby(a, b) {
              //从大到小依次排列
            return b - a
          }
          this.arr.sort(sortby)
        },
      }
```

> 如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。
>
> 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和  b，其返回值如下：
>
> - 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。  
> - 若 a 等于 b，则返回 0。  
> - 若 a 大于 b，则返回一个大于 0 的值。 

#### join()

* 把所有的元素放入一个字符串,元素通过指定的分隔符分割  
* 参数为join(`分隔符`)
* 返回值为一个字符串

#### push()

* 向数组的末尾添加一个或者多个元素,返回新的长度 ----> 操作原有的数组
* 参数为push(`向后添加的元素`)
* 返回值为,: 数组的一个新的长度

#### pop()

* 删除并返回数组中的最后一个数组
* 参数为   `空`
* 返回值为被删除的元素   如果删除的数组长度为 0  则返回 undefined  值

#### shift()

* 删除数组的第一个元素 
* 参数为  `空`
* 返回值为被删除的元素 , 如果删除的数组长度为 0   则返回undefined   值

#### unshift()

* 向数组的前面添加一个或者多个数组元素 操作原有的数组元素
* 参数为  `一个或多个元素`
* 返回值为数组的长度

#### reverse()

* 把数组的元素的顺序颠倒过来  --> 会操作原有的数组
* 参数为  `空`
* 返回值为操作后的数组

____________________________________________________________________________________-坑___________________________________________________________________________________________________________________________________________________-

## 对象

### 介绍

* 核心概念: **万物皆对象** ,使用对象来描述世间万物;
* 对象: 使用**属性**,描述事物的特征, 使用**方法**来描述**行为**,   就是对象这种语法.
* 对象: **属性和方法的集合**

#### 优势

* 我们之前学习过的对象Math() ;  new Date() ; 我们发现 , 只要学习对象的一些属性和方法,直接使用就可以得到自己想要的结果,例如,Math.random();
* **我们不用关心随机数是怎么产生的,只需要结果**
* 这就涉及到一个在编程世界内著名的思想: **面向对象思想,万物皆可对象**.
* 面对对象的思想: 找一个对象(工具). 看它身上有什么**方法**和**特点** ,能帮我干什么事情,然后我就可以用这个工具,按照我们的思维安排这个工具就可以做某
* 些事情.

```js
// 新找到一个日期对象
// Date 构造函数，构造出一个我们需要的工具，就是对象；
var date = new Date();

// 调用日期对象的获取年份的方法
date.getFullYear();

// Math对象
Math是 内置对象；
Math.floor();
```

* 特点: 
  * 实现高效的开发: 我们只需要知道**对象**(工具)有什么属性和方法,不需要知道对象里面是如何实现的,**在别人已经提供好的方法的基础上,在此实现我们想要的结果,开发的过程将大大缩短.**
  * **便于维护** : 因为你是单个对象(工具), 我们可以随时对你进行改造,修改; 满足我的需要.

#### 语法

#### 创建

*  构造函数

```js
var obj = new Object ();
console.log (obj);
```

* 字面量: 从字面上能看出数据的类型;

````js
var obj = {};// 这个也是一个没有属性和方法的对象 ,其本质和构造函数的对象是一样的
//仅仅是书写方式的不通
console.log (obj , typeof obj);
//输出{} Object;
//对象的数据类型为:Object;
````



#### 添加

* 字面量方式
* 如: 使用对象描述一个人名,先用字面量去声明一个对象,再给对象添加属性方法赋值.

```js

var obj ={};
//对象名.属性= 值;
obj.name = "大龙";
//对象上的任何方法都可以获取,和设置;

//标准语法
//对象.方法名 = function(){};
举例;
对象.方法名=function(变量(形参)){
//方法体(函数体)
}
```

* 使用字面量方式初始化对象,初始化赋值

```js
// 描述一个学生
var student = {
  name : '狗蛋',
  age : 12,
  gender : '男',
  sayName : function(){
    console.log(student.name);
  }
}
```

* 一个属性和一个值叫做**键值对** ,多个键值对中间使用逗号分隔,键的方式添加属性.

```js
// 对象[属性名]  属性名必须是String类型，里面可以写字符串；
var obj = {};
obj['name'] = '狗蛋';
obj['sayName'] = function(){
  console.log('你好，我叫' + obj['name']);
}
```



#### 获取

* 点方式获取

```js
//得到对象的名字,属性可以当成变量使用
console.log(obj.name);
//调用对象的方法,方法本质就是函数
obj.name;
```

* 一件键值对的方式访问对象;

```js
console.log(obj["name"]);
obj["name"]();

```

* 本质上**点方式**和**键值对**方式,没有任何差别
  * 只是**表现形式**上的差别只是吧点换成了[""];
  * 需要用键值对的方式就使用键值对
  * 但**一般**的获取方式就是   **点调用**

#### 遍历

* 数组可以遍历: 对象也可以遍历;  使用    for (     in     );

```js
//key是这个对象中的每个键,obj就是要遍历的对象.
for(var  key  in  obj ){
//循环操作方式
}
var obj ={
    name: "狗子",
    age:"12",
    gender: "男",
};

for ( var  key    in  obj ){
 console.log (key);
    //循环打印对象中的每个键
    //但是属性中的值没办法通过点方式获取
    console.log (obj[key])
}
//输出
//name 狗子
// age 12
// gender 男

```

type  [taɪp] 类型/种类

**typeof 后面跟上值可以查询数据的类型**

#### 注意

##### 对象中的属性

* 类型
  * 对象中的属性类型为 **string**类型

```js
  //key是这个对象中的每个键,obj就是要遍历的对象.
  for (var key in obj) {
    //循环操作方式
  }
  var obj = {
    name: "狗子",
    age: "12",
    gender: "男",
  };

  for (var key in obj) {
    console.log(key, obj.key);
    //循环打印对象中的每个键
    //但是属性中的值没办法通过点方式获取
  }
//输出
//name undefined
//age undefined
//gender undefined
//因为点方式的方式调用不到
```



##### 字符串分为数组

```js
var arr  = nums.solit(",");
```
##### .concat

* 数组的拼接: 把多个数组合并成一个新的数组,而不会改变原来的数组

```js
var arr = [1, 2];
arr = arr.concat('a');
arr = arr.concat(5, 6);
arr = arr.concat([4, 8], [9, 0]);

// 快速的复制一个数组,绝对不是 
// var arr_1 = arr;
var arr_1 = arr.concat();

```

### string类型

#### 字符串不可变

* 字符串不可变:
  * 旧的字符串赋值在一个变量上,给变量重新赋值新的字符串(完全新的字符串,或者拼接后字符串) , 就得字符串不是被覆盖; **在内存中游离**
  * 所以尽量避免大量使用字符串的拼接,这个算性能优化的一点.

#### 查找

* indexOf 方法 
  * 查询字符
  * 返回下标 未查询到返回  -1 ;

````js
  var str = "我爱北京天安门";

  // 
  // var res = str.indexOf("天");
  // 把要查询的字符串在 整个字符串内的位置的下标反给你；
  // 查询没有的数据，返回是-1；
  // console.log(res);
````



* charAt 方法
  * 查询下标
  * 返回字符

```js

  // // 查询下标出的字符，返回字符；
  // var res_2 = str.charAt(2);
  // console.log(res_2);
```

#### 转为数组

* 字符串与数组互转(复习)

```js
 // // 把字符串转为数组；
  var str_1 = "a|b|c";
  var arr = str_1.split("|");
  console.log(arr);
  str_1 = arr.join("ABC");
  console.log(str_1);

  // // 查询的方式，从后往前查；不常用；
  // var res_1 = str.lastIndexOf("门");
  // console.log(res_1);


  // // 返回 下标出的字符的ASCII 码值；
  // var res_3 = str.charCodeAt(0);
  // console.log(res_3);
```



#### 拼接与截取

* 下面使用的方法都没有对原字符串进行操作, 返回新的字符串
* concat 方法字符串操作方法  
  * 字符串拼接

```js
  var str = "woaibeijingtiananm";
  // 1. concat 可以与多个字符串进行拼接 +
   var res = str.concat("--------", '88888');
   console.log(str, res);//生成了一个新的字符串
```

* substring方法
  * 参数为: 一个**包左不包右** 区间
  * 返回一个新的字符串
  *  // 第一个参数：**截取开始**的下标，包括
  *  // 第二个参数：**截取结束**的下标，不包括

```js
var res = str.substring(4, 11);
console.log(str, res); //返回北京---beijing
```

* slice 方法
  * 使用方法跟上面一样
  * 可以使用负值- 
  * 使用方法是吧 "-"负值与字符串长度相加得到的数字就是第一个参数

```js
  // 3.slice
  var res = str.slice(2, 9);
  console.log(str, res);
  // 其他用法, 把负值和长度进行相加


  // 其他用法：把负值和长度进行相加
  // var res = str.slice(-6, 20);
整个字符串长度为18 与-6 相加得到12 
第一个值为12 ,第二个值不变的情况下
这样slice的值为(12,20)
从第12个开始到底20个结束,不包含底20个
  
```

### Aeeay   [ 数组 ]

#### 对元素操作 数组对象

* push 从数组的后面推入一个元素或者多个元素

```js
var arr = [1,2,3];

// 返回：修改后数组的长度
arr.push(4,5,6);
```

* pop 删除数组中的最后一个元素

```js
// 数组的pop方法用于将数组的最后一个元素移除
var arr = [1,2,3];

// 返回 被删除的元素；
arr.pop();
```

* unshift 从数组前面添加一个或者多个元素

```js
var arr  = [1,2,3]

//返回一个修改后数组的长度
arr.unshift ();
```

* shift 用于将数组的第一个元素移除;

```js
// 数组的shift方法用于将数组的第一个元素移除
var arr = [1,2,3];

// 返回 被删除的元素；
arr.shift(); 
```

* splice; 可以进行数组任意位置的增删改
* splice  [splaɪs]  结婚/桥接/捻接（两段绳子）
* splice   
  * 第一个值是表示从哪位**下标开始**, 
  * 第二个值是标明是**删除**多少个**元素**,
  * 第三个到之后到小括号的值都是**添加值**)
  * **注意**:这里的值是可以为表达式,或者变量;

```js
  // 数组的splice方法用于从数组的指定位置移除、添加、替换元素
  var arr = ['1', '2', '3', '4', '5'];
  // 对原数组操作
  // 作用：从下标3开始移除，总共移除1个元素 ，
  // 返回 被移除元素的数组
  arr.splice(3, 1);

  // 在c的后面添加7和8两个元素
  // 作用：从下标3开始添加，移除0个元素，把7，8加入；
  // 返回：一个空数组
  // 操作原数组；
  arr.splice(3, 0, 7, 8);
  console.log(arr);

  // 作用：从下标1开始替换，总共替换1个，用0替换 ；
  // 返回：被替换元素的数组
  arr.splice(1, 1, 0);
```

#### 数组与字符串的相互转换

* join  方法
  *  用于将数组中的多个元素以指定的分隔符链接成一个字符串

```js
  var arr = ["刘铁柱", "王大拿", "大王"];
  console.log(arr);

  arr = arr.join("**");
  console.log(arr);


  arr = arr.split("**");
  console.log(arr);

```

* split 字符串方法
  * 用于将**字符串分割**之后组成一个数组

```js
  //这个方法将一个字符串以指定的富豪分割成数组
arr = arr.split("**");
  console.log(arr);
//将输出在var 输入的内容

```

#### 查找元素

* indexOf: 方法
  * 根据䛾查找索引, 如果这个元素在数组中,返回索引,将返回 - 1 
  * 找元素在不在数组内部 

```js
var arr = [10,20,30]
console.log(arr.indexOf(30));  // 2
console.log(arr.indexOf(40));  // -1
```

* findlndex  方法 
  * 返回满足条件的元素的第一个元素的下标
  * 没有满足条件的返回一个   -1

```js

var arr = [10, 20, 30];
var res1 = arr.findIndex(function (item) {
  return item >= 20;
});
// 返回 满足条件的第一个元素的的索引
console.log(res1);  


var res2 = arr.findIndex(function (item) {
  return item >= 50;
});
// -1
console.log(res2);
```



#### 遍历数组

* for循环
* forEach :循环遍历数组

````js
  var arr = [10, 20, 30];
  arr.forEach(function(item, index, arr) {
    //----------------值的位置重要文字不重要
    //第一个位置是循环的数组元素
    //第二个位置是循环数组的下标
    //第三个位置是数组的名称(可以省略不写);
    console.log(item, index, arr);
  })
//输出:
// 10 0 (3) [10, 20, 30]
// 20 1 (3) [10, 20, 30]
// 30 2 (3) [10, 20, 30]
````

item [ˈaɪtəm  ]**项目**/一条/恋爱

index  [ˈɪndeks]  索引/指数/标志/  **在这指的是下标**



* filter 方法筛选出数组中满足条件的数组,**返回值是一个新的数组**

```js
  // 数组的filter方法用于将数组中满足条件的元素筛选出来
  // 筛选出数组中 小于 2000 的数据
  var arr_1 = [1500, 1800, 2200, 300, 2600, 800];
  // var res = arr_1.filter(function(item, index, arr) {
  //   return item > 2000;
  // });
  // fitler方法的的参数要求是一个函数，这个函数接收2个参数：item是数组中的每个元素，index是item对应的索引,arr代表当前的数组

  // 复制一个数组
var arr_2  = arr_1.filter(function (item,index) {
  return (表达式);
    //满足条件则返回哪一次的数据
})
  console.log(arr_1);
  console.log(arr_2);

```



#### 拼接与截取

* concat 方法
  * 拼接数组,不改变原数组,创建新数组
  * 返回一个新数组

```js
  // 数组的concat方法的作用是把多个数组合并成一个新的数组
  var arr1 = ["---------------"];
  var arr2 = ["++++++++++++++++"];
  var arr3 = ["==============="];
  var res = arr1.concat(arr2, arr3);
  console.log(res);
  
  // 复制一个数组
  var arr_1 = res.concat();
  console.log(arr_1);

```

* slice 截取数组:  不对原数组操作,返回是新的数组;

```js
  var arr = [21, 32, 1, 42, 41, 452, 1];
  // 表示 从下标1（包括），截取到下表为4(不包括),
  // var res = arr.slice(1, 4);

  // var arr_1 = arr.slice(1);
  // 如果不给第二个参数，默认就是把从start开始，到length结束的所有的元素截取

  // console.log(res);

  // 复制数组：如果省略两个参数，start默认是0，end默认是length
  var arr_1 = arr.slice();
  console.log(arr);
  console.log(arr_1);
```



#### 复制

```js
var  arr  = [ 10,20,30,40];
var arr_1 = [];
 arr.forEach(function(item,index,arr){
  arr_1.push (item);
})
var arr_2 = arr.filter(function(item,index,arr){
    return (item);
})


var arr_3  = arr.filter (function(item,index,arr ){
      //   // 满足条件的元素要返回
  //   // 条件成立的话（true ,false），会把满足条件的元素返回；
  //   // 直接使用的元素，隐式转化；
    return arr.indexOf(item) != -1;
}

                         
//后面不传入参数, 返回个新的数组
var arr_4 = arr.concat ();



//对数组进行操作:不输入参数,全部提取; 返回新的数组;
var arr_5 = arrslice();

```





### Object复习

* 对象是复杂类型,存储方式是 在**栈内声明地址**,在**堆中存放数据**,
* "=" 赋值号的 作用是复制一个变量的**值**到另一个变量
  * 但对象名里面存放的是指向 **堆** 的地址使用"="(赋值)号会把地址赋值给另一个变量
  * 从而不能产生一个新的对象,**只是**产生了一个指向对象的一个**变量**(内部存放着地址)
  * **总的来说**还是一个对象,不过只是有两个名字可以修改访问这个变量.



### date(时间)

* 介绍
  * JS中的Date类型是由早期Java.util.Date类型基础之上构建的，所以保存的是距离1970年1月1日0时的毫秒数来存储时间的。

* 创建
  * 使用Date()函数创建 (字符串类型___数据)	

```js
var nowDate = Date();
// 创建时间对象,得到的是当前的时间
//数据类型是字符串
//参数如果是一个表示时间的字符串
//参数为年/月/日/时/分/秒/毫秒,未写的默认为0;
```

* 获取当前时间**Get+时间名词();**

```js
 //创建一个对象对象名为s的时间对象
//Date[deɪt] 日期,日子
//get [ɡet]得到/接到/收到
//full [fʊl]满
//year [jɪə(r)]年;
//Month [mʌnθ]月份
//Minute [ˈmɪnɪt] 分钟
//Second [ˈsekənd] 秒钟(时间单位)
  var s = new Date();
//获取年份
  var 年份 = s.getFullYear();
  var 月份 = s.getMonth();
  var 日期 = s.getDate();
  var 星期 = s.getDay();
  var 小时数 = s.getHours();
  var 分钟 = s.getMinutes ();
  var 秒 = s.getSeconds();
  console.log(年份, 月份, 日期, 星期, 小时数, 分钟, 秒);
//console.log(`${h}年${月份}月${日期}日${小时数}时${分钟}分${秒}秒`);
//se6 变量语法
//(变量输出 使用``两个分号包含住${变量名1}${变量名2}  两个$中间的可以添加任意字符串)
```


![](assets\006.png)

* 时间戳
  * 获取从1970年1月1日到现在的总毫秒数.常说的**时间戳**

```js
var date = new Date();

console.log(date.valueOf());
value[ˈvæljuː ]价值/值,数值
console.log(date.getTime());
time[taɪm] 分钟、小时、年等/特指时间

console.log(1*date);//特别方法
console.log(Date.now());
```



### Math ()

#### 介绍  

>  数学对象

#### 获取随机数-Math.random();

**.random();**方法只能获取到0~1的一个随机的多浮点数

```js
// 获取随机数
var r = Math.random();

// 输出一个在 [0,1) 之间的浮点数，可以得到0，但是无法得到1
console.log(r); 
```

#### 获取一个随机整数

```js
// 获取一个 [0,10] 之间的随机整数
var r = Math.random();
r = r * (10 + 1) ;
r = Math.floor(r);
console.log(r); // 得到一个在 [0,10] 之间的整数
```

#### Math.round(x) 

>  把一个浮点数进行四舍五入取整

```js
console.log(Math.round(3.1));  // 3
console.log(Math.round(3.9));  // 4
console.log(Math.round(-3.1)); // -3
console.log(Math.round(-3.9)); // -4
```

#### Math.cell(x) ; 

>  把一个浮点数向下取整;

```js
console.log(Math.ceil(3.1));  // 4
console.log(Math.ceil(3.9));  // 4
console.log(Math.ceil(-3.1)); // -3
console.log(Math.ceil(-3.9)); // -3
```

#### Math. abs (x)

>  求一个绝对值   正数;

```js
console.log(Math.abs(3));  // 3
console.log(Math.abs(-3)); // 3
```

#### Math.max (x,y,z) ; 

> **求多个数 的最大值** &&**最小值** 

```js
console.log(Math.max(10,20));  // 20
console.log(Math.max(8,4,5,7,3)); // 8

console.log(Math.max(10,20));  // 10
console.log(Math.max(8,4,5,7,3)); // 3
```






## 对象






## 简单类型,复杂类型

### 简单类型的储存

* 简单类型

```js
var a = 10 ;
var b = a ;
	b = 20 ;
console.log (a ,b );
//输出10 ,20 也就是说a 的值不会受到b的改变而影响
```

*  **简单类型** 在把数据存储的在内存的**栈空间**
* **复杂类型**的数据存储在内存的**堆空间**中 
* 吧一个变量的值给另一个变量的时候,其实就是吧栈空间的数据(格子内的值赋值了)复制了一份

![](./assets/001.png)

* 把一个变量的值给另一个变量的时候,其实就是吧栈空间的数据(格子内的值赋值了)复制了一份

![](./assets/002.png)

* 当另一个的数据发生变化,会根据变量找到相对应的栈内存上盒子的内容,进行修改;
* **此时;简单类型的变量赋值给另一个便令,当一个值改变了,不会影响到原来的变量**

![](./assets/003.png)

### 复杂类型的储存

```js

var obj1 = {
  name : '狗蛋'
};
var obj2 = obj1;
obj2.name = '翠花';

// 输出 两个翠花 ， 也就是说，obj1的name属性受到了obj2的name属性影响
console.log(obj1.name,obj2.name); 
console.log (obj2==obj1);

输出:
金毛 金毛
true
```

* 复杂类型在内存的储存,赋值给其他变量,也是把格子内的内容复制了一份.
* 格子里是地址; 相当于两个对象内容是同一份地址;

![](./assets/004.png)

* **当另一个对象发生变化时, 修改的是同一个堆内存地址上的数据,所以obj1 和obj2修改的其实是同一个对象**

![](./assets/005.png)