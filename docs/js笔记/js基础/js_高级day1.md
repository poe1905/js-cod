## 面向对象编程 

## 编程的思想

* 面向过程(pop)
  * 面向过程就是分析出解决问题所需要的步骤,然后用函数的思想一步一步去实现它, 使用的时候在一步一步依次调用就可以了
* 面向对象 (oop)
  * 面向对象就是把事物全部都分成对象
* **两者之间的区别**
  * 面向过程: 小项目dame
  * 面向过程: 多人合作大项目

### 面向对象的三大特性

* 封装性[已经准备好的功能准备好,负责使用]
* 继承性[来自父级对象继承下来的属性和方法]
* 多态性[可以放到一块,也可以单独使用]

#### 优缺点

* 面向过程
  * 有点: 性能比面向对象高,步骤联系紧密
  * 缺点,不好维护, 不易多次使用及拓展

* 面向对象
  * 有点: 已维护,可复用,可拓展,灵活性高
  * 缺点:性能没有面向过程高

### ES6中的类和对象

* 类: 是泛指的一类的概念
  * 例如:人类,或者狗,
    * -->泛指类型
* 对象: 是指的某实例化之后的具体的东西,如某一个人类,有具体指向的人,或者是特殊指出的狗
  * -->姚明,动物园或者家里的狗狗

## 类和对象

*  创建类

```js
class 类名 {
    constructor (uname) {
        this.uname = uname ; 
    }
}
//利用类创建对象 new
 var 对象名 =  new 类名 (参数) {
   
}
```

### 类中的属性和方法

#### 属性-->constructor

* constructor
  * 使用constructor关键字创建构造函数函数

* 在类中的固有属性需要在constructor中去定义

#### 方法-->直接定义

* 方法名  ( ) { } ;
* 在类中的属性名不需要使用**function**定义,**直接使用**方法名和小括号方框括号就行

### 继承--> extends

* 自类需要使用父类的方法或者属性就需要使用继承关键字extends

```js
  class 子类名 extends 父类名 {
    constructor(姓名, 性别, 毛色) {
      super(姓名, 性别)
      this.毛色 = 毛色
    }
```

* **super** 如果使用父类的属性,又要定义自己的属性,就需要使用**super()**关键字来调用父类的构造函数,之后吧形参传入,





### this的指向问题

this==>构造函数

new对象的方法中this==>调用者

*  构造函数内部的**this**指向的是创建的实例化对象,因为,new的时候内部的所欲属性**全部**指向实例化对象

* 在class中的方法中的**this**指向的是调用者,class在实例话对象中调用的时候,this指向就会变成实例化出来的对象,`但如果是在class中的方法中的事件调用了这个方法`,则其中的this会指向调用的事件源,这样会造成this指向发生错乱,
  * **解决方式**,因为方法中的this指向的是事件源,事件源中肯定没有这个方法,这样就需要在构造函数中吧this提取出来 
  * 然后在使用this的时候用提取出来的that ,这样本身调用this 的时候会调用它自己本身,在想使用构造函数上面的方法和属性的时候,使用that就不会出错了

```js

```

## 构造函数和原型

### 介绍

* 构造函数是一种特殊的函数,主要是用来初始化对象,即为对象成员变量赋初始值,它总与new一起使用.我们可以吧对象中的一些公共的属性和方法抽取出来,然后封装到这个函数里面.

```js
function Fn  ( ) { };
```



### 创建对象的三种方式

* 对象字面量
* new Object() [构造函数]
* 自定义构造函数

### 使用构造函数时要注意一下两点

1.构造函数用于创建某一类对象,其首字母要大写

2.构造函数要和new 一起使用才有意义

### new在执行的时候会做的四件事情

![](C:\Users\ly\Documents\黑马文档\js学习笔记md\docs\js笔记\assets\gj04.png)

### 静态对象和实例对象

* 静态成员
  * **向构造函数内部**添加的成员是静态成员

> 静态成员是通过点的方式添加进构造函数内部
>
> 通过点的方式会把 方法添加到**Construct** 中,如果 new这个构造函数 的时候 实例对象是**没有**这个方法的
>
> 静态成员只能通过点的方式去访问 也就是怎么添加进去的怎么访问
>
> 不怎么常用感觉

* 实例成员
  * **在构造函数内部**的添加的成员是实例成员

> 实例成员是在构造函数内部书写 每次实例化构造函数时 **都会重新初始化**这个函数到实例对象中
>
> ​	浪费内存空间    
>
> 一般我们是吧在构造函数内部的方法定义在原型对象之中==>	构造函数.prototype属性中

#### 构造函数小问题

* **内存浪费问题**
* 当实例化对象的时候,属性好理解,属性名属性值都是简单数据类型,但方法却是函数类型,是复杂数据类型
* 那么实例化对象的时候就会创建一个新的**属性**去存放这个复杂数据类型的内存地址,这个地址又指向这个堆的复杂数据类型,每次实例化这个构造函数的时候就会重新创建一个内存空间去存放这个复杂数据类型的数据地址,这样会造成**内存浪费**



### 构造函数和原型prototype

#### 介绍

* 什么是原型对象? 原型对象就是一个属性,是构造函数的一个对象,我们也称呼,prototype为原型对象
* 每个构造函数都有一个属性,prototype
* 作用? :是为了共享方法,从而达到节省 内存效果

> 构造函数是通过原型去分配的函数,是所有对象共享的.
>
> 
>
> javaScript 规定,每个构造函数都有一个prototype 属性,指向另一个对象.注意这个proprietary就是一个对象,这个对象里的所有属性和方法,都会被构造函数所拥有.我们可以吧那些不变的方法直接定义在prototype 对象上,这样所有对象的实例就可以共享这些方法

![gj02](assets\gj02.png)

````js
实例
function Star (uname, age) {

​		this.uname = uname;
​		this.age = age;
​		// this.sing = function () {
​		// 	console.log(this.name + '在唱歌');
​		// }

​	}
​	Star.prototype.sing = function () {
​		console.log(this.uname + '在唱歌');
​	}

​	var zxc = new Star('周星驰', 22);
​	var ldh = new Star('刘德华', 22);
​	// console.log( Star.prototype );
​	ldh.sing();
​	zxc.sing();

````

**总结: 所有公共的属性写在构造函数内,所有的公共方法写在原型对象里面**

疑问? 为什么创建一个对象,都可以自动调用原型对象上面找方法呢?

因为 每个对象都有一个属性就是对象原型 ,去执行原型对象.

### 对象原型 :    ____proto____

**作用: 指向prototype**

构造函数和原型对象都会有一个属性proto  指向构造函数prototype 原型对象,之所以我们对象可以使用构造函数prototype原型对象的属性和方法,就是因为对象有proto原型的存在.

> 注意: __proto__  是一个非标准属性,不可以拿来赋值,或者设置 [只读属性] 
>
> 1. ____proto____对象原型和原型对象 prototype 是等价的
> 2. __proto___   对象原型的意义就在于为对象的查找机制提供一个方向,或者说一条路线.但是它是一个非标准属性,因此实际开发中. 不可以使用这个属性,他只是内部指向原型对象prototype

![](C:\Users\ly\Documents\黑马文档\js学习笔记md\docs\js笔记\assets\gj.03.png)

------

**总结:每一个对象都有一个原型, 作用是指向原型对象prototype**

**统一称呼: proto  原型,               prototype称为原型对象**

------



### constructor构造函数

> **<u>记录是哪个构造函数创建出来的</u>**
>
> 指回构造函数本身

原型(proto)和构造函数(prototype) 原型对象里面都有一个属性constructor 属性,  constructor 我们称为构造函数,因为它指回构造函数本身. constructor 主要是用于记录该对象引用哪个构造函数  , 它可以让原型独享重新指回原来的构造函数 ,   一般情况下 ,  对象的方法都是在构造函数的原型对象中设置. 如果有多个对象的方法, 这样修改后的原型独享constructor 就不再指向当前构造函数了,  此时 , 我们可以在修改后的原型对象中,   添加一个constructor 指向原来的构造函数.

**总结: constructor 主要作用可以指回原来的构造函数**



### 构造函数/实例/原型对象三者之间的关系

![](assets\gj01.png)

注: 如果是以一个对象的方式给原型对象添加方法 ?

```js
Star.prototype = {
    sing : function () {},
    dance: function () {}
};

此时会覆盖原先prototype中的内容，传入一个新的对象，那么此时就不知道构造函数是哪个了
所以我们要指回构造函数：constructor：构造函数

```

- 在使用构造函数创建写实例方法的时候可以使用**对象点方法**的方式去向**prototype**属性内部添加方法
- 也可以使用{}对象的方式去添加方法,但是使用这个方法会覆盖到**prototype属性**内的**constructor**的指向这个属性的指向非常重要,但使用对象的方式去添加会覆盖掉这个属性,需要手动的去添加这个属性

### 原型链

__只可意会不可言传__

> 作用 : 提供一个成员查找机制, 或者说是一个规则,去查找

### JavaScript的成员查找机制(规则)

每个对象上面都会有proto隐藏属性

原型对象也不例外,所以原型对象可以根据proto找到创造他的原型对象 

从某一个原型对象往上面找只能找到创造他的原型对象,之后在网上找一层会找到创造出他的原型对象,

知道找到Object这个内置对象,然后再往上面找只能找到null了, 因为Object中没有原型对象了

一般情况下使用自定义构造函数创建的对象的原型对象是Object()对象

> ____proto____ 原型 的意义就是就在于为对杨成员查找机制提供一个方向，或者说是一条路线



### 



### 拓展内置对象

> 可以通过原型对象，对原来的内置对象仅限拓展自定义的方法。比如给数组增加自定义求偶数和的功能。

```js
  var arr = Array(2, 21, 123, 11111, 5, 2, 21, 4)
  console.log(arr);
 //给Array内的原型对象内添加一个偶数和 的方法(函数)
  Array.prototype.偶数和 = function() {
    var sum = 0;
//this指向的是调用者会指向调用这个方法的数组这样就不需要传参数就可以获取到数组对象
    for (var i = 0; i < this.length; i++) {

      if (this[i] % 2 == 0) {
        sum = sum + this[i]
      }
    }
//方法(需要返回值)
    return sum;
  }
//
  Array.prototype.最大值 = function() {
    var max = this[0];
    for (var i = 0; i < this.length; i++) {

      if (max < this[i + 1]) {
        max = this[i + 1]
      }
    }

    return max;
  }
  Array.prototype.最小值 = function() {
    var min = this[0];
    for (var i = 0; i < this.length; i++) {

      if (min > this[i]) {
        min = this[i]
      }
    }

    return min;
  }
  Array.prototype.偶数集合 = function() {
    var arr = [];
    for (var i = 0; i < this.length; i++) {

      if (this[i] % 2 == 0) {
        arr.push(this[i]);
      }
    }

    return arr;
  }
  Array.prototype.奇数集合 = function() {
    var arr = [];
    for (var i = 0; i < this.length; i++) {

      if (this[i] % 2 != 0) {
        arr.push(this[i]);
      }
    }

    return arr;
  }


  console.dir(Array);

  console.log(arr.偶数和());
  console.log(arr.最大值());
  console.log(arr.最小值());
  console.log(arr.偶数集合());
  console.log(arr.奇数集合());

```



### 继承

**ES6之前没有给我们提供extends 继承 . 我们可以通过构造函数+ 原型对象模拟实现继承, 被称为组合继承**

* **call()**  关键字
  * 调用这个函数，并且修改函数运行时的this 指向
  * fun.call(**thisArg**,agr1,agr2,agr3,......); call 把父类的this指向子类
  * thisArg: 当前调用的函数this  的指向对象
  * agr1.2 :  传递的参数数

**利用构造函数实现子类的继承**

#### 属性的继承

```SJ

```



#### 方法的继承





### 类的本质

* 类的本质还是function
* 类的所有方法都定义在类耳朵prototype属性上
* 类创建的实例,里面也有____proto____   ,指向类的prototype原型对象
* 所以ES6的类它的绝大部分功能,ES5都可以做到,新的class写法只是让对象原型的写法更加清晰,更像面向对象的编程语法而已





### ES6中的数组和字符串的新方法

> 迭代(遍历)方法：forEach()、map()、filter()、some()、every()；

#### 数组的新方法

some,every是返回true&false

map,filter 是返回一个新数组

reduce 是让数组的前后两项进项某种计算,返回最终操作结果

forEach是没有返回值的

* 这几个数组的方法都是使用一个function(){} 去操作这个数组
* 都需要   **数组名**.**方法名**(function  (参数1 ,参数2 ,参数3 )  {  **函数体**   }  )
  * 参数1: 指的是在这个函数体运行中的每个值
  * 参数2: 指的是在这个函数体中的每个值的下标
  * 参数3: 指 的这个循环的数组

```js
    var arr = [214, 4, 4, 53, 543]
```



**forEach()**

* 遍历数组
* 没有返回值

```js
//遍历所有元素
```

**map()**

* 遍历数组
* 有一个由新元素组成的数组返回

```js
//遍历一个数组, 返回一个新数组 
	//如果是数组元素参与计算则会返回出参与计算的数
    var sun = arr.map(function(ass, ie) {
      return ass * 10

    })
    
        console.log(sun);// 会出现[2140, 40, 40, 530, 5430]
//如果是下标参与计算则会返回一个新的数组里面有参与计算的索引值,则不会改变这个数组中索引的值
    var sun = arr.map(function(ass, ie) {
      return ie * 10

    })
    
        console.log(sun);// 会出现[0, 10, 20,30,40]
    // arr.map 创建一个新数组给返回出来  不管是什么参加计算会循环数组长度 传入的新的数组内返回出来
    var sun = arr.map(function(ass, ie) {
      return 1 * 2

    })
        console.log(sun);// 会出现 [2,2,2,2,2]
```



**filter()**

* 过滤数组(遍历数组)
* 返回符合判断条件的新数组==> 不会对元素组进行操作

```js
//筛选元素

    // arr.filter   会把每个符合条件判断式的元素返回出去到一个新的数组内
    // 如果是下标参与计算  也是只会返回元素  当下标参与计算的时候
    var sun = arr.filter(function(pp, i) {
        return i > 2;
        //其中的返回值不是参与计算的下标或者参数数据
        //返回值固定位内部元素
        //每次循环都会根据这个return后面的表达式的布尔值去绝对是否去返回当前的元素
        //返回加入到一个新的数组内

      })
```



**some()**

* 查找这个元素(遍历数组中是否有这个元素)
* 返回值为true&&false

```js
//查找元素
    // arr.some       用来去查找一个元素是否在这个数组内部,如果查找到这个元素停止这个循环并且返回出一个为true 的布尔值如果查找这个元素都没找到这个元素就会返回false
    // 不仅仅可以判断某个数是否在这个数组内,而且可以判断这个数组中是否有大于某个条件的元素如果有就返回这个元素

    var sun = arr.some(function(ins, i) {
        console.log();

        return ins > 400;
      })
    
```



**every()**

* 把数组中的每个值去参与判断,
* 返回值为true或false
  * 当所有元素的判断式都为true时返回true
  * 当数组中的某一个元素的判断为false 时返回false

```js
//遍历数组每一项,每一项都返回true ,如果全部都返回true 的时候,最终结果返回true

    // arr.every   会拿出所有的元素参与循环,并且给每个元素进行判断,只有所有元素全部都判断成功的情况下,整个方法才会返回一个true 反之则会返回false

    var sun = arr.every(function(pp, i) {
      return pp > 41;
    })

```

#### 字符串的新方法

* **trim()**

> 给字符串使用的方法 删除字符串两边的空白



### 函数进阶

#### 函数的调用和定义

> 1.使用命名的方式去定义
>
> 2.使用匿名函数的方式去 书写,可以使用自调用的方式去执行
>
> 3.使用构造函数的方式去书写.正常去调用
>
>  _在构造函数去创建函数的时候必须吧函数体以字符串的方式去当做参数传入到构造函数内去
>
> _ 传的参数也是字符串,函数体也是字符串--不常用

#### 函数的调用方式

>  1.普通函数的调用
>
> 2.对象方法
>
> 3.构造函数的方法
>
> 4.绑定时间函数
>
> 5.定时器函数
>
> 6.自调用函数(立即执行函数)



#### 高阶函数

> 指吧一个函数当做参数或者返回值,在另一个函数内时
>
> 当一个函数去吧另一个函数当做形参传入或者把这个函数当做一个返回值返回的时候
>
> //就把这个函数称作高阶函数







#### this指向



* **this.当前调用者**

| 函数类型                      |    this指向    |
| :---------------------------- | :------------: |
| 普通声明函数                  |    Windows     |
| 构造函数==>实例出来的实例对象 | 指向实例化对象 |
| 事件绑定函数                  |                |
| 计时函数                      |    Windows     |
| 对象内部的方法                |  指向这个对象  |
| 自调用函数                    |                |





#### 改变this的指向

javascript为我们提供了三种方法

bind(),call(),apply()

**bind()**------>**极其重要**

* 在改变this的时候**不**会执行这个函数

```js
//用于需要改变这个函数内部的this 指向而不需要去执行
  function als(arr) {
    console.log(arr);

  }
  var 对象 = {
      uname: "狮王",
      als: function(params) {
        console.log(this);

      }
    }
    //   als.bind(对象)
    //   对象.als.bind(als)
  var ae86 = "拓海"
  对象.als.bind(als, ae86)

```



**call()**

* 在改变this的时候会执行这个函数

```js
  function als(arr) {
    console.log(arr);

  }
  var 对象 = {
      uname: "狮王",
      als: function(params) {
        console.log(this);

      }
    }
    //   als.bind(对象)
    //   对象.als.bind(als)
  var ae86 = "拓海"
  对象.als.call(als, ae86)
```



apply()

````js

  //   apply--> 这个方法是函数对象的方法 只有函数类型的数据才可以使用三个方法,使用这个方法是改变这个函数中的this 指向改变到响应的对象
  //一般和数组对象用在一块
  // 例如
  //   var arr = ["天坛", "地坛", "颐和园"]
  var arr = [3, 5, 2]
  var std = Math.min.apply(null, arr)
  console.log(std);
````



### javascript的严格模式



正常模式

* 正常的编辑模式下

严格模式

* 开启严格模式："use strict"
  * 脚本开启严格模式
    * 整个关键字之后的所有代码均会按照严格模式检测
  * 函数开启严格模式
    * 在函数作用域内的代码进行严格模式检测

给一个函数

* 严格模式的要求:
  * 对于变量不能不定义就使用或赋值
  * 对于this指向问题
    * 以前的全局声明函数的this 指向是windows 现在改为undefined
  * 对于构造函数的new 的问题
    * 以前构造函数可以当做普通函数来使用,现在构造函数的内部的this指向指向undefined所以只能是实例化对象之后在使用
  * 对于函数内部的形参 以前是可以重复命名的,以后命名就**必须不能**重复命名

* 严格模式的好处
  * 1.代码可以更快的加载,
  * 2.安全性更高
  * 3.代码更加的规范



### 闭包

#### 变量的作用域

> 作用域分为全局作用域和局部作用域
>
> 1.函数内部可以使用全局作用域
>
> 2,函数外部不可以使用局部作用域
>
> 3.当函数执行完毕时,本作用耳朵局部变量会销毁

* ### 介绍:

  * 当一个函数使用另一个函数内的局部变量, 这个现象就是闭包现象
  * 闭包(closure): 指有权访问另一个函数作用域中变量的函数(并不权威,有点片面)

* 作用

  * 延伸变量的作用范围

```js
    var uname = "我是爷爷";

  function 父函数() {


    var uname = "我是父亲";

    return function 子函数() {
      return uname

    }

  }
  var ass = 父函数()
  console.log(ass());//打印我是父亲












var uname = "我是爷爷"

  function 父函数() {


    var uname = "我是父亲";

    return function 子函数() {
      return this.uname

    }

  }
  var ass = 父函数()
  console.log(ass());//打印我是爷爷

//执行过程
//1.执行父函数 
	1,1 父函数内去执行吧我是父亲赋值给uname 
    1,2 返回整个函数代码
    1,3由于返回的代码到ass 又看到ass 后面有小括号就执行当前的函数代码
  2,执行子函数
	2,1 执行子函数之后会找到this指向中的uname中的属性值 由于在 console.log(ass())中执行当前函数的this指向为windows 所以会获取到我是爷爷的这个数值,
    2,2  返回获取到的值 我是爷爷
 3.执行打印事件打印出我是爷爷
 4, 程序结束

```

关于闭包的练习题

```js

注册事件练习：打印索引值

<body>
  <div>
    <ul>
      <li>1</li>
      <li>2</li>
      <li>3</li>
      <li>41</li>
      <li>15</li>
      <li>16</li>
      <li>17</li>
      <li>1s</li>
    </ul>
  </div>
</body>

<script>
  //获取到页面中所有的下标
  var li = document.querySelectorAll("li")

  for (let i = 0; i < li.length; i++) {

    li[i].onclick = function() {

      (function(index) {
        console.log(index);

      })(i)

    }
  }
</script>
使用自调用函数来当做点击事件中的函数体
//当点击事件执行的时候执行一遍自调用函数
//自调用函数的执行过程
//1. 每次吧获取到的i的值当做实参传入到本函数内
//2. 吧传入的实参赋值给形参index 参与打印
//这样就可以每次点击的时候吧当前循环到的索引值通过自调用函数保存到了index内



思考题：
var name = "The Window";
   var object = {
     name: "My Object",
     getNameFunc: function() {
     return function() {
     return this.name;
     };
   }
 };
console.log(object.getNameFunc()())
----------------------------------------------------------------------------------------
var name = "The Window";　　
  var object = {　　　　
    name: "My Object",
    getNameFunc: function() {
    var that = this;
    return function() {
    return that.name;
    };
  }
};
console.log(object.getNameFunc()())
```





### 递归

#### 什么是递归

> 递归: 递归就是在一个函数内部可以调用其本身, 那么这个函数就是递归函数,
>
> 简单理解: 函数内部自己调用自己,这个函数就是递归函数
>
> 递归: 函数调用函数其本身
>
> **注意** 递归函数的作用和新欢一样,由于递归很容易发生"栈溢出"错误,所以必须要加退出条件return

**练习 n~1的阶乘**

```js
//利用递归函数求1~n的阶乘 1 * 2 * 3 * 4 * ..n
 function fn(n) {
     if (n == 1) { //结束条件
       return 1;
     }
     return n * fn(n - 1);
 }
 console.log(fn(3));
```

**练习递归球裴波那栔 数列(兔子数列)**

```js

// 利用递归函数求斐波那契数列(兔子序列)  1、1、2、3、5、8、13、21...
// 用户输入一个数字 n 就可以求出 这个数字对应的兔子序列值
// 我们只需要知道用户输入的n 的前面两项(n-1 n-2)就可以计算出n 对应的序列值
function fb(n) {
  if (n === 1 || n === 2) {
        return 1;
  }
  return fb(n - 1) + fb(n - 2);
}
console.log(fb(3));


```

#### 使用递归去遍历数据

* 遍历复杂数据

```js
  var data = [{
    id: 1,
    name: '家电',
    goods: [{
      id: 11,
      gname: '冰箱',
      goods: [{
        id: 111,
        gname: '海尔'
      }, {
        id: 112,
        gname: '美的'
      }, ]
    }, {
      id: 12,
      gname: '洗衣机'
    }]
  }, {
    id: 2,
    name: '服饰'
  }];

  //数据类型为数组 内部有对象的 模式
  //  对象里面包括这数据对象
  // 有下层包括的对象数组里面有一个特殊的键名 为[goods] ___  这个值为系统约定好了的

  // 通过id名去查找这个对象并且返回这个元素
  var sdf = 11



  function 遍历(数组, 查找id) {
    var avs = {}
    数组.forEach(function(str, i) {

      // console.log(查找id);


      if (str.id == 查找id) {
        avs = str
        return
      } else if (str.goods) {

        avs = 遍历(str.goods, 查找id)

      }
    });

    return avs
  }


  // 通过id 去寻找在整个复杂数据中 对象的id正确的对象

  // 对于这样的复杂数据类型
  //需要用到递归思想,也就是自己调用自己
  // 当遇到数据内部有相同的数据需要处理的时候就会使用到递归思想
  /**
   * 1.首先先定义一个函数
   * 2. 定义一个空对象返回  这个查找到的这个对象
   * 3. 利用forEach(function(){}) 数组的方法去遍历这个对象
   * 4. 遍历对象的时候去判断 两种可能
   *    4.1 第一种对象的id等于查找到的id 就把找到当前的id所在的对象返回给新定义的空对象
   *    4.2 第二种情况是没找到这个id值 但是 可以通过这个对象里面的一个 -固定的- 属性值 去再次使用本函数去定义
   *    4.4 解释: 当处于第二种情况下 会继续在执行这个函数去遍历这个属性值中存放的数组   再次去遍历数组中的对象  直到吧整个对象中的固定属性中的所有有id值的对象全部遍历完毕, 或者找到一个符合查找id 的元素,这样就处于了第一种情况,第一种情况只要发生了就会吧查找出来的对象赋值给了新定义的对象 并且会停止本次数组的循环 当forEach循环过后 就已经说明本次需要查找的id对象,已经查找出来
   *  5. return 出来第一次创建出来的空对象 (因为只要这个forEach循环结束就一定是从第一种情况出来) 所以这一个对象就一定不是空对象 一定是本次查找出来符合id值的对象.
   * 6. 本次函数结束 在函数外面定义变量接收即可
   */
  console.log(遍历(data, sdf));

```

* 通过 递归去深拷贝一个对象

### 深拷贝与浅拷贝

* 浅拷贝
  *  指的是拷贝数据的栈数据
  * 在**栈中存放的数据为可以拷贝的数据**
  * 除此之外没有可以拷贝的数据
* 深拷贝
  * 深拷贝顾名思义是深度去拷贝一个对象或者是数组
  * 但由于**只能在栈中存放才可以拷贝**,所以,把每次需要拷贝的对象或者数组,里面的栈中的数据提取出来,之后再通过不断的赋值去复制给新的对象或者数组,
  * 深拷贝的一个最重要的思想就是利用浅拷贝把 在栈中存储的数据通过遍历,循环,递归的方式 吧属性名和属性值,统统 通过浅拷贝的方式去复制(=)给了 一个新的对象或者数组



### 正则表达式

* 什么是正则表达式?=

> 正则表达式:  就是用于匹配字符串的一个方式,或者是方法
>
> 在javascript中正则表达式也是一个对象 --RegExp()--<== 这个就是正则表达式的构造函数
>
> 有对象就会有方法
>
> 方法就是--test()
>
> 方法的参数是字符串的形式
>
> 返回值为布尔值true&&false

##### 正则表达式的创建

* 使用构造函数的方式

```js
var reg = new RegExp(/123/);
consol.log(reg)
```

* 使用**字面量的方式**

```js
var regs = /123/;
 //像数组 的字面量是通过[数据1 ,数据2] ==> 正则的字面量是/参数/
//在js里面是通过两个//里面的内容来声明了正则表达式
```

#### 正则的验证

* 使用test()
  * 方法参数为字符串,
  * 返回值为布尔值

```js
  var script = `abc`
  var str = /[a]/
  console.log(str.test(script))
//打印true
```

#### 正则的中的特殊字符

* 原字符
* 边界符
  * ^: 在/^      / 正则符号的前面
    * 表示正则匹配开头为^后面的字符串
  * $: 在/    $/  正则符号的后面
    * 表示正则匹配结尾为$之前的字符串
  * 当两个边界符同时使用时
    * 在/^   $/    ==>两个同时出现
    * 表示整个正则处于精确匹配模式==> 必须符合 ^$之间的所有条件
* 量词符
  * ***** 表示重复0次或者多次
  * { }在条件语句的后面  多用于条件使用次数
  * {n} 表示前面的条件匹配了n次 ==> 写几次就匹配几次
  * {n,} 表示匹配条件n到无穷   ==> 匹配最少n次 最多不限 相当于    的次数>=n
  * {n,m} 表示匹配条件从n到m ==> 匹配最少n次最多m次  相当于      n<=次数<=m

| 符号  |                             说明                             |
| :---: | :----------------------------------------------------------: |
|   *   |             表示重复0次或者多次=====>相当于{0,}              |
|   +   |             用于匹配1次或者多次=====>相当于{1,}              |
|   ?   |              用于匹配0次到1次=====>相当于{0,1}               |
|  {n}  |   在条件语句的后面  多用于条件使用次数==> 写几次就匹配几次   |
| {n,}  | 表示匹配条件n到无穷   ==> 匹配最少n次 最多不限 相当于    的次数>=n |
| {n,m} | 表示匹配条件从n到m ==> 匹配最少n次最多m次  相当于      n<=次数<=m |
|       |       {n,m}之间是不准有任何的空格n和m的值只能为数字的        |



* 括号总结
* []  内容选择符
  * 表示在[]内部的内容选择1个 生效一个即可
* () 优先级选择器 这个比较高级不会用
  * 待定?
* **取反**^
  * 取反的符号跟边界符一样,位置不同,不同的效果
  * 取反生效区间在条件的前面,如果想要取反则在条件的前面加上取反符号

#### 预定义类

| 预定类 | 说明                                           |
| ------ | :--------------------------------------------- |
| \d     | 匹配[0-9]                                      |
| \D     | [^0-9]                                         |
| \w     | [a-zA-Z0-9_]==> 匹配任意字符串、数字下和横线   |
| W      | [^a-zA-Z0-9]==》除了所有的字符串、数字和下横线 |
| \s     | [\t\r\v\n\f]==>匹配空字符串                    |
| \S     | [^\t\r\v\n\f]==>匹配非空字符串                 |



#### replace替换

* 是字符串的方法
  * 一般用于**替换屏蔽敏感字符**
* 字符串.replace(正则表达式,"替换上去的字符")

```js
字符串.replace(正则表达式,"替换上去的字符")
  var script = `abc`
  var str = /[a]/
    //   console.log(str.test(script))
  var 新字符 = script.replace(str, "*")
  console.log(新字符);
//*bc
```

