

# 对象

## 介绍

* 核心概念: **万物皆对象** ,使用对象来描述世间万物;
* 对象: 使用**属性**,描述事物的特征, 使用**方法**来描述**行为**,   就是对象这种语法.
* 对象: **属性和方法的集合**

### 优势

* 我们之前学习过的对象Math() ;  new Date() ; 我们发现 , 只要学习对象的一些属性和方法,直接使用就可以得到自己想要的结果,例如,Math.random();
* **我们不用关心随机数是怎么产生的,只需要结果**
* 这就涉及到一个在编程世界内著名的思想: **面向对象思想,万物皆可对象**.
* 面对对象的思想: 找一个对象(工具). 看它身上有什么**方法**和**特点** ,能帮我干什么事情,然后我就可以用这个工具,按照我们的思维安排这个工具就可以做某些事情.

```js
// 新找到一个日期对象
// Date 构造函数，构造出一个我们需要的工具，就是对象；
var date = new Date();

// 调用日期对象的获取年份的方法
date.getFullYear();

// Math对象
Math是 内置对象；
Math.floor();
```

* 特点: 
  * 实现高效的开发: 我们只需要知道**对象**(工具)有什么属性和方法,不需要知道对象里面是如何实现的,**在别人已经提供好的方法的基础上,在此实现我们想要的结果,开发的过程将大大缩短.**
  * **便于维护** : 因为你是单个对象(工具), 我们可以随时对你进行改造,修改; 满足我的需要.

## 语法

### 创建

*  构造函数

```js
var obj = new Object ();
console.log (obj);
```

* 字面量: 从字面上能看出数据的类型;

````js
var obj = {};// 这个也是一个没有属性和方法的对象 ,其本质和构造函数的对象是一样的
//仅仅是书写方式的不通
console.log (obj , typeof obj);
//输出{} Object;
//对象的数据类型为:Object;
````



### 添加

* 字面量方式
* 如: 使用对象描述一个人名,先用字面量去声明一个对象,再给对象添加属性方法赋值.

```js

var obj ={};
//对象名.属性= 值;
obj.name = "大龙";
//对象上的任何方法都可以获取,和设置;

//标准语法
//对象.方法名 = function(){};
举例;
对象.方法名=function(变量(形参)){
//方法体(函数体)
}
```

* 使用字面量方式初始化对象,初始化赋值

```js
// 描述一个学生
var student = {
  name : '狗蛋',
  age : 12,
  gender : '男',
  sayName : function(){
    console.log(student.name);
  }
}
```

* 一个属性和一个值叫做**键值对** ,多个键值对中间使用逗号分隔,键的方式添加属性.

```js
// 对象[属性名]  属性名必须是String类型，里面可以写字符串；
var obj = {};
obj['name'] = '狗蛋';
obj['sayName'] = function(){
  console.log('你好，我叫' + obj['name']);
}
```



### 获取

* 点方式获取

```js
//得到对象的名字,属性可以当成变量使用
console.log(obj.name);
//调用对象的方法,方法本质就是函数
obj.name;
```

* 一件键值对的方式访问对象;

```js
console.log(obj["name"]);
obj["name"]();

```

* 本质上**点方式**和**键值对**方式,没有任何差别
  * 只是**表现形式**上的差别只是吧点换成了[""];
  * 需要用键值对的方式就使用键值对
  * 但**一般**的获取方式就是   **点调用**

### 遍历

* 数组可以遍历: 对象也可以遍历;  使用    for (     in     );

```js
//key是这个对象中的每个键,obj就是要遍历的对象.
for(var  key  in  obj ){
//循环操作方式
}
var obj ={
    name: "狗子",
    age:"12",
    gender: "男",
};

for ( var  key    in  obj ){
 console.log (key);
    //循环打印对象中的每个键
    //但是属性中的值没办法通过点方式获取
    console.log (obj[key])
}
//输出
//name 狗子
// age 12
// gender 男

```

type  [taɪp] 类型/种类

**typeof 后面跟上值可以查询数据的类型**

## 注意

#### 对象中的属性

* 类型
  * 对象中的属性类型为 **string**类型

```js
  //key是这个对象中的每个键,obj就是要遍历的对象.
  for (var key in obj) {
    //循环操作方式
  }
  var obj = {
    name: "狗子",
    age: "12",
    gender: "男",
  };

  for (var key in obj) {
    console.log(key, obj.key);
    //循环打印对象中的每个键
    //但是属性中的值没办法通过点方式获取
  }
//输出
//name undefined
//age undefined
//gender undefined
//因为点方式的方式调用不到
```



###   字符串分为数组

```js
var arr  = nums.solit(",");
```
### .concat

* 数组的拼接: 把多个数组合并成一个新的数组,而不会改变原来的数组

```js
var arr = [1, 2];
arr = arr.concat('a');
arr = arr.concat(5, 6);
arr = arr.concat([4, 8], [9, 0]);

// 快速的复制一个数组,绝对不是 
// var arr_1 = arr;
var arr_1 = arr.concat();

```




## 简单类型,复杂类型

### 简单类型的储存

* 简单类型

```js
var a = 10 ;
var b = a ;
	b = 20 ;
console.log (a ,b );
//输出10 ,20 也就是说a 的值不会受到b的改变而影响
```

*  **简单类型** 在把数据存储的在内存的**栈空间**
* **复杂类型**的数据存储在内存的**堆空间**中 
* 吧一个变量的值给另一个变量的时候,其实就是吧栈空间的数据(格子内的值赋值了)复制了一份

![](./assets/001.png)

* 把一个变量的值给另一个变量的时候,其实就是吧栈空间的数据(格子内的值赋值了)复制了一份

![](./assets/002.png)

* 当另一个的数据发生变化,会根据变量找到相对应的栈内存上盒子的内容,进行修改;
* **此时;简单类型的变量赋值给另一个便令,当一个值改变了,不会影响到原来的变量**

![](./assets/003.png)

### 复杂类型的储存

```js

var obj1 = {
  name : '狗蛋'
};
var obj2 = obj1;
obj2.name = '翠花';

// 输出 两个翠花 ， 也就是说，obj1的name属性受到了obj2的name属性影响
console.log(obj1.name,obj2.name); 
console.log (obj2==obj1);

输出:
金毛 金毛
true
```

* 复杂类型在内存的储存,赋值给其他变量,也是把格子内的内容复制了一份.
* 格子里是地址; 相当于两个对象内容是同一份地址;

![](./assets/004.png)

* **当另一个对象发生变化时, 修改的是同一个堆内存地址上的数据,所以obj1 和obj2修改的其实是同一个对象**

![](./assets/005.png)